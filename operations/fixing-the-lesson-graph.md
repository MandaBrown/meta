# Fixing the lesson graph

Getting errors trying to delete precursors / prerequisites?

Run ```rake ttm:fix_lesson_requisites``` in apangea.

This task will create a migration in the db/migrate_ directory that will execute the SQL necessary to repair the graph representation's integrity.

The migrations generated by the above rake task will insert rows that are out of sync with the sequence on master. After running the migrations, you should run the `db/reset_sequences_for_shards.rb` script to fix the problem.

## Fixing the Lesson Graph

We are making use of the [acts-as-dag] (https://github.com/resgraph/acts-as-dag) gem to keep track of our Lessons and Prerequisites. The [Lesson] (https://github.com/thinkthroughmath/apangea/blob/fa8e7ab18fdf6b723c003d6317d1cd014e67c948/app/models/lesson.rb) model has_dag_links, and the [LessonRequisite] (https://github.com/thinkthroughmath/apangea/blob/fa8e7ab18fdf6b723c003d6317d1cd014e67c948/app/models/lesson_requisite.rb) model acts_as_dag_links.

The acts-as-dag gem stores the [DAG] (http://en.wikipedia.org/wiki/Directed_acyclic_graph) in an interesting way - all links between nodes (lessons) are stored in the edge (lesson requisites) table, both direct and indirect. This means that lookups are fast - but also means that there is redundant information stored that can get out of sync. Because of this, we should only manipulate Lessons and Requisites through the application and allow acts-as-dag to keep the graph consistent, if possible. Unfortunately, either through bugs in the gem or through previous manual updates to the Lessons and LessonRequisites, our graph has become internally inconsistent.

The main symptom of an unhealthy graph that I have seen so far is the inability to delete edges (lesson prerequisites); errors we have seen include:

  - Cannot create an indirect link with a count less than 1
    - This led to the discovery that we have some 'missing' indirect links in our graph.

<img src="https://www.evernote.com/shard/s17/sh/6fd1d116-e579-4b02-8a0f-aa9df001eceb/0c283b61e618ad9a1fd343b08434fec6/res/decccf65-e95b-4cee-9734-4c1f3e2d4333/skitch.png"/>

Typically, acts-as-dag would store the edges (Lesson Requisites) on this graph in 3 records, so that it is quick to find all of the ancestors for a lesson:

| id | ancestor | descendant | direct | count |
| ---|----------|------------|--------|-------|
|  1 | Lesson 1 | Lesson 2   | true   | 1     |
|  2 | Lesson 2 | Lesson 3   | true   | 1     |
|  3 | Lesson 1 | Lesson 3   | **false**  | 1 |

However, there were instances in our graph where the indirect link (between Lessons 1 and 3, in this example) was missing from the lesson_requisites table, which would put the graph in a state such that it would throw an error when the user tried to delete one of the lessons, because it would make indirect links with negative counts while trying to rewire the graph to accomodate the deletion.

  - cannot destroy this edge
    - This led to the discovery that some of the 'count' values in our edge table (lesson requisites) are inaccurate. The 'count' field is supposed to describe the number of unique paths between lessons (the ancestor and descendant). For example, in this graph:

<img src="https://www.evernote.com/shard/s17/sh/4cabfa11-71fc-4e3a-826d-8b10706d3ca6/b08ad048fca140d98167f66f7c0015aa/res/b812ed79-f69b-4f9b-8143-1d54f7f928d9/skitch.png" />

There are 2 unique ways to get from Lesson 1 to Lesson 3, so the lesson_requisite table describing this graph would look like this:

| id | ancestor | descendant | direct | count |
| ---|----------|------------|--------|-------|
|  1 | Lesson 1 | Lesson 2   | true   | 1     |
|  2 | Lesson 2 | Lesson 3   | true   | 1     |
|  3 | Lesson 1 | Lesson 3   | false  | **2** |
|  4 | Lesson 1 | Lesson 4   | true   | 1     |
|  5 | Lesson 4 | Lesson 3   | true   | 1     |

Incorrect values in the 'count' column can also cause acts-as-dag to throw errors while trying to maintain consistency during a graph update.

While investigating incorrect 'count' values and verifying the counts reported from the check, I found that we nave numerous indirect links (lesson requisites) that should have been dropped to zero (and therefore deleted). In general, the numbers seem pretty far off and I suspect that there is a bug in acts-as-dag that is causing this problem, whereas the 'missing links' issue seems more likely caused by manipulation of the graph data outside of rails.

Both of these are documented in PlanBox ticket [#5404475] (https://www.planbox.com/stories/5404475), including steps to reproduce. There may be further ways in which the graph can become unhealthy, but so far I have only explored the specific issues that have shown themselves through visible bugs.

To address these problems, I made a fork of [acts-as-dag] (https://github.com/MandaBrown/acts-as-dag/tree/check_and_heal) that employs the [RGL] (https://github.com/fmeyer/rgl) to double-check the data structure and alert us of inconsistencies, which we can then manually address.

On the apangea side, there is a new rake task:
```rake ttm:fix_lesson_requisites```

This task will create migrations in the db/migrate directory that will execute the SQL necessary to repair the graph representation's integrity. 

Another utility that is now available with the changes to the acts-as-dag gem is the ability to easily visualize all or part of the lesson requisite graph.

In order to create an image, you will have to install [GraphViz] (http://www.graphviz.org/) (can be installed with HomeBrew on a Mac); otherwise, you will just get .dot files that describe the graph (these can also be opened in GraphViz).

From the rails console, you can get the RGL version of the LessonRequisite graph like this:
```g = LessonRequisite.rgl_graph```

After which, you can manipulate g in any of the ways that are provided by the RGL:
```ruby
require 'rgl/dot'
g.write_to_graphic_file 'png', '/tmp/lesson_requisites'
```

You can filter the graph and only look at a portion of it:
```ruby
# Use BFS to find all of the ancestors of a node:
tree = g.bfs_search_tree_from(Lesson.find(lesson_id))
# If you want to look at what the graph actually looks like for
# those values, you need to filter the original graph by the tree
# so that you get all edges and not just the ones that were
# traversed by BFS:
g_filtered = g.vertices_filtered_by { |v| tree.has_vertex? v }
# Do anything with g_filtered that you would with g, like generate an image:
g.write_to_graphic_file 'png', '/tmp/filtered_lessons'
# or a .dot file for GraphViz:
g.dotty
```
